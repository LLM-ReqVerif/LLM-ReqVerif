/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * File: ert_main.c
 *
 * Code generated for Simulink model 'integrator_12B'.
 *
 * Model version                  : 1.30
 * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024
 * C/C++ source code generated on : Sun Nov  3 11:37:02 2024
 *
 * Target selection: ert.tlc
 * Embedded hardware selection: ARM Compatible->ARM 10
 * Code generation objectives:
 *    1. Execution efficiency
 *    2. RAM efficiency
 * Validation result: Not run
 */

#include <stddef.h>
#include <stdio.h>            /* This example main program uses printf/fflush */
#include "integrator_12B.h"   /* Model header file */

/* ESBMC uses this function signature for non-deterministic boolean inputs. */
_Bool nondet_bool(void);

/* ESBMC uses this function signature for non-deterministic double inputs. */
double nondet_double(void);

/* 
 * Use ESBMC’s built-in assertion mechanism. 
 * Example usage: __ESBMC_assert(condition, "error message");
 */

/*
 * This function is auto-generated by Simulink. We typically associate rt_OneStep
 * with a timer interrupt in embedded code. For verification here, we will not
 * rely on rt_OneStep in a permanent loop. Instead, we will call integrator_12B_step()
 * in our own loop in main().
 *
 * Still, we keep rt_OneStep() for completeness (Simulink scaffolding).
 */
void rt_OneStep(void)
{
  static _Bool OverrunFlag = 0;

  /* Disable interrupts here */

  /* Check for overrun */
  if (OverrunFlag) {
    rtmSetErrorStatus(rtM, "Overrun");
    return;
  }

  OverrunFlag = 1;

  /* Save FPU context here (if necessary) */
  /* Re-enable timer or interrupt here */
  /* Set model inputs here if needed */

  /* Step the model */
  integrator_12B_step();

  /* Get model outputs here if needed */

  /* Indicate task complete */
  OverrunFlag = 0;

  /* Disable interrupts here */
  /* Restore FPU context here (if necessary) */
  /* Enable interrupts here */
}

/*
 * Main function with assertion-based checks for requirements.
 * We do the following:
 *  1. Initialize the model.
 *  2. Run a finite number of loops (e.g., 100 iterations).
 *  3. In each iteration:
 *     - Assign nondet or fixed values to rtU.* inputs as needed.
 *     - Save the old states (UnitDelay states).
 *     - Call integrator_12B_step().
 *     - Check each requirement (#1..#4 and sub-Req #4a/#4b) using __ESBMC_assert.
 *  4. If any error status arises, we break out early.
 *
 * Properties are conditionally compiled using #ifdef VERIFY_PROPERTY_N
 * (e.g., VERIFY_PROPERTY_1, VERIFY_PROPERTY_2, etc.). ESBMC can define these
 * macros via compiler command-line flags. We do NOT define them here.
 *
 * This way, each property can be verified independently or in combination
 * by specifying the relevant -DVERIFY_PROPERTY_N flags at compile time.
 */
int_T main(int_T argc, const char *argv[])
{
  /* Unused arguments */
  (void)(argc);
  (void)(argv);

  /* Initialize the model */
  integrator_12B_initialize();

  /* For clarity, define a loop count for our "simulation" / verification steps */
  const int loop_count = 100;

  /* We will store the prior states in local variables (non-static) each iteration. */
  double prev_yout = 0.0;
  double prev_xin  = 0.0;

  for (int i = 0; i < loop_count; i++)
  {
    /* If the model has reported an error, break early. */
    if (rtmGetErrorStatus(rtM) != (NULL)) {
      break;
    }

    /* -------------------------
     *  Assign or nondet inputs
     * ------------------------- */
    rtU.xin   = nondet_double();   /* Input to be integrated */
    rtU.T     = nondet_double();   /* Time step (Delta t)     */
    rtU.reset = nondet_bool();     /* Reset control flag      */
    rtU.ic    = nondet_double();   /* Initial Condition       */
    rtU.BL    = nondet_double();   /* Bottom Limit            */
    rtU.TL    = nondet_double();   /* Top Limit               */

    /*
     * Save the old states (which represent UnitDelay_DSTATE and UnitDelay1_DSTATE).
     * By design, integrator_12B uses them to hold the previous yout & previous xin.
     */
    prev_yout = rtDW.UnitDelay_DSTATE;
    prev_xin  = rtDW.UnitDelay1_DSTATE;

    /* Step the model (run one cycle). */
    integrator_12B_step();

    /*
     * =======================================================================
     * Now we place assertion-based checks for each requirement (#1..#4).
     * We will only compile these checks if the corresponding VERIFY_PROPERTY_*
     * macro is defined externally (e.g., via -DVERIFY_PROPERTY_1).
     * =======================================================================
     */

    /*
     * -----------------------------------------------------------------------
     * Requirement #1:
     *   Reset scenario. If reset == true, then yout must be set to ic (or
     *   saturated at BL/TL). We also handle the case TL < BL.
     * -----------------------------------------------------------------------
     */
#ifdef VERIFY_PROPERTY_1
    if (rtU.reset) {
      /* If TL >= BL, normal bounding */
      if (rtU.TL >= rtU.BL) {
        if ((rtU.ic >= rtU.BL) && (rtU.ic <= rtU.TL)) {
          /* (a) ic within [BL, TL] => yout = ic */
          __ESBMC_assert(rtY.yout == rtU.ic,
                         "Req #1a: reset=true, ic within [BL,TL], yout == ic");
        } 
        else if ((rtU.ic >= rtU.TL) && (rtU.BL <= rtU.TL)) {
          /* (b) ic >= TL >= BL => yout = TL */
          __ESBMC_assert(rtY.yout == rtU.TL,
                         "Req #1b: reset=true, ic >= TL, saturate yout=TL");
        } 
        else if ((rtU.ic <= rtU.BL) && (rtU.BL <= rtU.TL)) {
          /* (c) ic <= BL <= TL => yout = BL */
          __ESBMC_assert(rtY.yout == rtU.BL,
                         "Req #1c: reset=true, ic <= BL, saturate yout=BL");
        }
      }
      else {
        /* If TL < BL, reversed bounding */
        if (rtU.ic >= rtU.BL) {
          /* (d) yout=BL if ic >= BL, but remember BL is the 'upper' in this scenario */
          __ESBMC_assert(rtY.yout == rtU.BL,
                         "Req #1d: reset=true, TL<BL, ic >= BL => yout=BL");
        } 
        else if (rtU.ic <= rtU.TL) {
          /* (e) yout=TL if ic <= TL, but TL is the 'lower' here */
          __ESBMC_assert(rtY.yout == rtU.TL,
                         "Req #1e: reset=true, TL<BL, ic <= TL => yout=TL");
        }
      }
    }
#endif /* VERIFY_PROPERTY_1 */


    /*
     * -----------------------------------------------------------------------
     * Requirement #2:
     *   The output yout shall remain bounded by TL and BL.
     *   If TL >= BL => BL <= yout <= TL.
     *   If TL < BL  => TL <= yout <= BL.
     *   This check is every cycle.
     * -----------------------------------------------------------------------
     */
#ifdef VERIFY_PROPERTY_2
    if (rtU.TL >= rtU.BL) {
      __ESBMC_assert((rtY.yout >= rtU.BL) && (rtY.yout <= rtU.TL),
                     "Req #2: yout must stay within [BL, TL] when TL >= BL");
    } else {
      __ESBMC_assert((rtY.yout >= rtU.TL) && (rtY.yout <= rtU.BL),
                     "Req #2: yout must stay within [TL, BL] when TL < BL");
    }
#endif /* VERIFY_PROPERTY_2 */


    /*
     * -----------------------------------------------------------------------
     * Requirement #3:
     *   When reset == false and the integrator is not saturating, we compute
     *   yout = y_{pv} + (T/2)*(xin + x_{in,pv}), i.e. Tustin formula.
     *   Then saturate if needed. We do a simplified check: if we see that
     *   yout is not pinned at boundary, we assume it's not saturating.
     * -----------------------------------------------------------------------
     */
#ifdef VERIFY_PROPERTY_3
    if (!rtU.reset) {
      /* Compute the theoretical Tustin result: */
      double tustin_result = prev_yout + 0.5 * rtU.T * (rtU.xin + prev_xin);

      /* Identify whichever is lower vs higher limit for bounding check */
      double lowerLim = (rtU.TL < rtU.BL) ? rtU.TL : rtU.BL;
      double upperLim = (rtU.TL < rtU.BL) ? rtU.BL : rtU.TL;

      /* If final yout is strictly inside the bounding region, we expect no saturation. */
      if ((rtY.yout > lowerLim) && (rtY.yout < upperLim)) {
        /* Check Tustin eq within some tiny tolerance (floating compare) */
        double epsilon = 1e-12; /* a small tolerance for double rounding */
        __ESBMC_assert(
          ((rtY.yout - tustin_result) < epsilon) && ((rtY.yout - tustin_result) > -epsilon),
          "Req #3: Tustin formula must hold if not saturating and not reset"
        );
      }
    }
#endif /* VERIFY_PROPERTY_3 */


    /*
     * -----------------------------------------------------------------------
     * Requirement #4:
     *   Tustin output must approximate integral of xin over time.
     *   Sub-Req #4a: After 10 seconds at 10Hz (100 cycles) with T=0.1, xin=1.0
     *                => final yout ~ 10.0 ± 0.1.
     *   Sub-Req #4b: After 10 seconds at 10Hz with T=0.1, xin=cos(t),
     *                => yout ~ sin(t) ± 0.1.  (where t=10 => sin(10)).
     *
     * For ESBMC, typically we set the inputs to nondet. However, if we want
     * to check property #4a or #4b specifically, we'd do so by forcing the
     * inputs in a scenario or at least at iteration 100.
     *
     * Below are stubs that check at i=99 (the 100th iteration, 0-based).
     * In a real environment, you'd ensure rtU.xin=1.0 or cos(...) each iteration,
     * plus rtU.T=0.1, plus no saturations, etc.
     * For illustration, we do an assertion if i==99.
     * -----------------------------------------------------------------------
     */
#ifdef VERIFY_PROPERTY_4a
    /* We interpret the property to check at the end of the 100th cycle: i == 99 (0-based). */
    if (i == 99) {
      /*
       * Suppose we forced rtU.xin=1.0 and rtU.T=0.1 each step with no saturations,
       * Then the ideal integral after 10s is 10.0. We'll check ±0.1.
       */
      __ESBMC_assert(
        (rtY.yout >= 9.9) && (rtY.yout <= 10.1),
        "Req #4a: after 100 cycles at 10Hz with xin=1.0 => yout ~ 10 ± 0.1"
      );
    }
#endif /* VERIFY_PROPERTY_4a */

#ifdef VERIFY_PROPERTY_4b
    /* Check at iteration 99 as well. */
    if (i == 99) {
      /*
       * If we forced rtU.xin = cos(t), with t=0..10 in steps of 0.1,
       * the integral is sin(10) - sin(0) = sin(10).
       * sin(10) ~ -0.544021...
       */
      double sin_of_10 = -0.5440211108893698; /* approximate */
      double lowerBound = sin_of_10 - 0.1;
      double upperBound = sin_of_10 + 0.1;
      __ESBMC_assert(
        (rtY.yout >= lowerBound) && (rtY.yout <= upperBound),
        "Req #4b: after 100 cycles at 10Hz with xin=cos(t), yout ~ sin(10) ± 0.1"
      );
    }
#endif /* VERIFY_PROPERTY_4b */

    /* 
     * End of iteration: states are automatically updated inside integrator_12B_step().
     * We do not need extra code to update them here. 
     * We'll proceed to next iteration.
     */
  } /* end for loop */

  return 0;
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
